doc Args {
    Title "Argument Passing in TCL"
    Description {
	<p>
	Arguments to a proc are just a list and TCL allows the use of the args argument to access a variable length list of arguments to the proc.<br>
	Different interpretations of the args list allows us to build different mechanisms for passing arguments
	</p>
	<ul>
	<li>Pass by Value</li>
	<li>Pass by Reference</li>
	<li>Pass by Name</li>
	<li>Pass by Dict</li>
	<li>Pass by Dict ~ Tilde Shorthand</li>
	
	</ul>
	
	<h3>Pass by Value - the standard TCL way</h3>
	<p>
	TCL procs pass values to procedures using an ordered sequence.<br>
	Assignment of values to the argument variables is made by matching the value to the corresponding variable in the sequence of arguments.
	</p>
	<pre class="example">
	# Pass by Value
	proc volume {radius length} {
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume $radius $length
	50.24
	</pre>

	<h3>Pass by Reference</h3>
	<p>
	Upvar can be used to reference a variable in the caller's namespace.<br>
	The local and callers variable names can be different but here they are both the same.
	<p>
	Using "pass by reference" should be avoided because changes in the local proc variable will affect the caller and can lead to some unexpected bugs. 
	
	</p>
	<pre class="example">
	# Pass by Reference
	proc volume {radiusVar lengthVar} {
	    upvar 1 $radiusVar radius
	    upvar 1 $lengthVar length
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume radius length
	50.24
	</pre>
	This technique can be generalised to handle any sequence of arguments.
	<pre class="example">
	proc volume {args} {
	    foreach varName $args {upvar 1 $varname $varName}
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 3
	% set length 4
	% volume radius length
	50.24
	</pre>

	<h3>Pass by Name</h3>
	Here the local variables are initially set to hold the same value as 
	the caller's variables. 
	This technique ensures that changes to the local variable do not affect the caller.
	<pre class="example">
	# Pass by name
	proc volume {radiusVar lengthVar} {
	    set radius [uplevel 1 set $radiusVar]
	    set length [uplevel 1 set $lengthVar]
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume radius length
	50.24
	</pre>
	This technique can be generalised to handle any sequence of arguments.
	<pre class="example">
	proc volume {args} {
	    foreach varName $args {set $varName [uplevel 1 set $varName]}
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 3
	% set length 4
	% volume radius length
	50.24
	</pre>
	<h3>Pass by Dict</h3>
	Pass by dict provides a way of passing "named arguments" where the sequence of the args does not matter.<br>
	For procs that take a long list of arguments it becomes convenient to pass a dict rather than remember the order of arguments.<br>
	It is also suitable for procs that have many optional arguments.
	<pre class="example">
	proc volume {dict} {
	    set radius [dict get $dict radius]
	    set length [dict get $dict length]
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume [list radius $radius length $length]
	50.24
	</pre>
	It is a pain having to construct the dict when calling this proc and it would be nice to be able to write
	<pre class="example">
	volume [list radius $radius length $length]
	or
	volume radius $radius length $length
	</pre>
	To allow both methods to call the proc correctly I use 
	<pre class="example">
	if { [llength $args]==1 } {set args [lindex $args 0]}
	</pre>
	which gives
	<pre class="example">
	proc volume {args} {
	    if { [llength $args]==1 } {set args [lindex $args 0]}
	    set radius [dict get $args radius]
	    set length [dict get $args length]
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume [list radius $radius length $length]
	50.24
	% volume radius $radius length $length
	50.24
	</pre>
	
	<h3>Pass by Dict ~ Tilde Shorthand</h3>
	<p>
	Instead of writing long lists of <i>name value name value name value ...</i> pairs we can create dict's from local variables using [doc_link dict_from].<br>
	A qcode shorthand way of writing that uses a tilde ~ to indicate that the following list items are variable names rather than name-value pairs.
	The proc can use [doc_link args2dict] or [doc_link args2vars] to parse the argument list and interpret it as a dict or a list of variable names.<br>
	<pre class="example">
	proc volume {args} {
	    set dict [args2dict $args]
	    set radius [dict get $dict radius]
	    set length [dict get $dict length]
	    return [expr 3.14*$radius*$radius*$length]
	}
	% set radius 2
	% set length 4
	% volume radius $radius length $length
	50.24
	% volume [dict_from radius length]
	50.24 
	% volume ~ radius length
	50.24
	</pre>
    }
}