package require tcltest
eval ::tcltest::configure $argv
# Ensure package is loaded from ./qcode rather than /usr/lib/tcltk
set auto_path [linsert $auto_path 0 ./qcode]
package require qcode
package require json

namespace eval ::qcode::test {
    namespace import ::tcltest::*
    namespace path ::qc
    
    test http_encoding-1.0 {http_encoding xml } -setup {
    } -body {
        http_encoding {} {<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <Response xmlns="https://www.example.com">
      <Result>
        <ClientHeader>
          <PassKey>999</PassKey>
        </ClientHeader>
        <Type>TEST</Type>
        <Data>Testing</Data
      </Result>
    </Response>
  </soap:Body>
</soap:Envelope>}
    } -result {utf-8}

    test http_encoding-1.1 {http_encoding xml default} -setup {
    } -body {
        http_encoding {} {<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <soap:Body>
    <Response xmlns="https://www.example.com">
      <Result>
        <ClientHeader>
          <PassKey>999</PassKey>
        </ClientHeader>
        <Type>TEST</Type>
        <Data>Testing</Data
      </Result>
    </Response>
  </soap:Body>
</soap:Envelope>}
    } -result {utf-8}

    test http_encoding-1.2 {http_encoding http charset} -setup {
    } -body {
        http_encoding {Content-Type {text/html; charset=utf-8}} {}
    } -result {utf-8}

    test http_encoding-1.3 {http_encoding http charset not found} -setup {
    } -body {
        http_encoding {Accept-Encoding gzip} {}
    } -result {iso8859-1}

    test http_encoding-1.4 {http_encoding http long headers } -setup {
    } -body {
        http_encoding {Accept-Encoding gzip Content-Type {text/html; charset=utf-16} Transfer-Encoding chunked Accept-Language Fr Host fr.yahoo.com} {}
    } -result {unicode}

    test http_encoding-1.5 {http_encoding http long headers no charset } -setup {
    } -body {
        http_encoding {Accept-Encoding gzip Content-Type {text/html} Transfer-Encoding chunked Accept-Language Fr Host fr.yahoo.com} {}
    } -result {iso8859-1}

    test http_header_encoding-1.0 {http_header_encoding no charset } -setup {
    } -body {
        http_header_encoding {Accept-Encoding gzip Content-Type {text/html} Transfer-Encoding chunked Accept-Language Fr Host fr.yahoo.com}
    } -result {}

    test http_header_encoding-1.1 {http_header_encoding charset } -setup {
    } -body {
        http_header_encoding {Accept-Encoding gzip Content-Type {text/html; charset=utf-16} Transfer-Encoding chunked Accept-Language Fr Host fr.yahoo.com}
    } -result {unicode}

    test http_header_encoding-1.2 {http_header_encoding empty headers } -setup {
    } -body {
        http_header_encoding {}
    } -result {}

    test IANAEncoding2TclEncoding-1.0 {IANAEncoding2TclEncoding utf-8 upper} -setup {
    } -body {
         IANAEncoding2TclEncoding {UTF-8}
    } -result {utf-8}

    test IANAEncoding2TclEncoding-1.1 {IANAEncoding2TclEncoding error} -setup {
    } -body {
         IANAEncoding2TclEncoding {qwerty}
    } -returnCodes 1 -result {Unrecognized encoding name 'qwerty'}

    test IANAEncoding2TclEncoding-1.1 {IANAEncoding2TclEncoding latin} -setup {
    } -body {
         IANAEncoding2TclEncoding {latin1}
    } -result {iso8859-1}

    test http_header-1.0 {http_header ok} -setup {} -body {
        http_header Content-Type application/json
    } -result {Content-Type: application/json}
    test http_header-1.1 {http_header error} -setup {} -body {
        http_header Rest-Sign "aHNkZnNqa2ZsanNkZmFzZGdkZmFnZmFnYWdmZ2FkZ2FnYXNkZmFmZ2FkZ2Zhc2RmYWdmYWdmZHNh\nZ3dnZXJhZWJ6aHJoYWVk"
    } -returnCodes 1 -result "The value of http header, \"Rest-Sign: aHNkZnNqa2ZsanNkZmFzZGdkZmFnZmFnYWdmZ2FkZ2FnYXNkZmFmZ2FkZ2Zhc2RmYWdmYWdmZHNh\nZ3dnZXJhZWJ6aHJoYWVk\", contains newline characters."

    test http_post-1.0 {http_post} -body {
        set response [http_post -timeout 30 -content-type "text/plain; charset=utf-8" -accept "text/plain; charset=utf-8" -- http://httpbin.org/post data "Here's the POST data"]
        set dict [::json::json2dict $response]
        if { [lsort [dict keys $dict]] ne {args data files form headers json origin url} } {
            return "false: key mismatch"
        }
        foreach {varname value} {
            args {}
            data "data=Here%27s%20the%20POST%20data"
            files {}
            form {}
            json null
            url "http://httpbin.org/post"
        } {
            if { [dict get $dict $varname] ne $value } {
                return "false: value $varname returns [dict get $dict $varname] (should have been $value)"
            }
        }
        set headers [dict get $dict headers]
        if { [lsort [dict keys $headers]] ne {Accept Connection Content-Length Content-Type Host} } {
            return "false: header keys mismatch"
        }
        foreach {key value} {
            Content-Type {text/plain; charset=utf-8}
            Content-Length 33
            Accept {text/plain; charset=utf-8}
            Connection close
            Host httpbin.org
        } {
            if { [dict get $headers $key] ne $value } {
                return "false: header values mismatch"
            }
        }
        return true
    } -result true

    test http_post-1.1 {http_post (multipart)} -setup {} -body {
        set data [list {name foo contents Apples} {name bar contents Oranges}]
        set response [http_post -headers {} -content-type "multipart/form-data" -data $data http://httpbin.org/post]

        set dict [::json::json2dict $response]
        if { [lsort [dict keys $dict]] ne {args data files form headers json origin url} } {
            return false
        }
        foreach {name value} {
            args {}
            files {}
            json null
            url http://httpbin.org/post
            data {}
        } {
            if { [dict get $dict $name] ne $value } {
                return false
            }
        }
        foreach {name value} {
            foo Apples
            bar Oranges
        } {
            if { [dict get [dict get $dict form] $name] ne $value } {
                return false
            }
        }

        set headers [dict get $dict headers]
        if { [lsort [dict keys $headers]] ne {Accept Connection Content-Length Content-Type Host} } {
            return false
        }
        foreach {name value} {
            Accept */*
            Content-Length 243
            Connection close
            Host httpbin.org
        } {
            if { [dict get $headers $name] ne $value } {
                return false
            }
        }
        if { ! [string match {multipart/form-data; boundary=*} [dict get $headers Content-Type]] } {
            return false
        }
        return true
    } -result true

    cleanupTests
}
namespace delete ::qcode::test
